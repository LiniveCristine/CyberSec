# ğŸŒ CNAME (Canonical Name)

## ğŸ“Œ O que Ã© CNAME

- Tipo de **registro DNS**
- Utilizado para criar **aliases (apelidos)** de domÃ­nios
- O **alias aponta para um domÃ­nio real**
- **Aliases nÃ£o possuem endereÃ§o IP**

ğŸ“Œ Exemplo:

```
blog.exemplo.com.br  â†’  exemplo.github.io
```

- `blog.exemplo.com.br` â†’ alias
- `exemplo.github.io` â†’ domÃ­nio canÃ´nico (possui IP)

---

# âš ï¸ Vulnerabilidade: Subdomain Takeover

## ğŸ”“ O que Ã©

- Ocorre quando um **subdomÃ­nio (alias)** aponta para um **serviÃ§o de terceiros**
- Esse domÃ­nio de terceiros pode:
  - Estar desativado
  - NÃ£o estar em uso
  - Estar disponÃ­vel para compra

ğŸ“Œ Se alguÃ©m comprar esse domÃ­nio:

- Passa a **controlar o subdomÃ­nio (alias)**
- Pode hospedar conteÃºdo malicioso

---

## ğŸ§¨ Exemplo PrÃ¡tico

```
meublog.com  â†’  meublog.github.io
```

- `meublog.com` Ã© um **alias**
- Se `meublog.github.io` estiver disponÃ­vel:
  - Qualquer pessoa pode registrar
  - O subdomÃ­nio passa a apontar para o atacante

---

# ğŸ” Resolvendo CNAME com Python

## ğŸ“¦ InstalaÃ§Ã£o da Biblioteca

Utilizamos a biblioteca **dnspython**.

### OpÃ§Ã£o 1 â€“ pip:

```bash
pip3 install dnspython
```

### OpÃ§Ã£o 2 â€“ apt:

```bash
sudo apt install python3-dnspython
```

ğŸ“Œ Ã‰ necessÃ¡rio ter o **pip** instalado.

---

## ğŸ ImportaÃ§Ã£o do MÃ³dulo

```python
import dns.resolver
```

---

## ğŸ§© FunÃ§Ã£o `resolve()`

- Suporta diversos tipos de registros DNS
- Incluindo **CNAME**

### ğŸ“Œ Exemplo:

```python
respostas = dns.resolver.resolve("google.com", "CNAME")
```

ğŸ“Œ A funÃ§Ã£o verifica se:

- O domÃ­nio Ã© um **alias**
- E para qual domÃ­nio canÃ´nico ele aponta

---

## ğŸ“¥ Acessando o CNAME

- `respostas` Ã© um objeto **Answer**
- ContÃ©m TTL, mÃºltiplos registros e o CNAME

```python
print(respostas[0])
```

- O Ã­ndice `0` retorna o **CNAME**

---

# ğŸš¨ Tratamento de Erros DNS

## âŒ Sem CNAME

- Erro retornado:

```python
dns.resolver.NoAnswer
```

- Indica que o domÃ­nio **nÃ£o Ã© um alias**

```python
try:
    ...
except dns.resolver.NoAnswer:
    ...
```

---

## âŒ DomÃ­nio Inexistente

- Erro retornado:

```python
dns.resolver.NXDOMAIN
```

- Indica que o domÃ­nio **nÃ£o existe**

```python
except dns.resolver.NXDOMAIN:
    ...
```

---

# ğŸ” Brute Force de SubdomÃ­nios CNAME

Assim como na resoluÃ§Ã£o de subdomÃ­nios, utilizamos uma **wordlist**.

---

## ğŸ“„ Wordlist via Argumento

```python
with open(sys.argv[2]) as wordlist:
```

- O usuÃ¡rio informa o arquivo:

```
wordlist.txt
```

---

## ğŸ”§ Montagem do SubdomÃ­nio

```python
subdominio = f"{i}.{dominio}"
```

- Cada palavra da wordlist gera um subdomÃ­nio a ser testado

---

# â±ï¸ Tratamento de Timeout

## âš ï¸ Erro de Timeout

- Ocorre quando o DNS demora para responder

```python
dns.resolver.LifetimeTimeout
```

ğŸ“Œ Problema:

- Ignorar o subdomÃ­nio pode gerar **falso negativo**

---

## â³ SoluÃ§Ã£o: Repetir Tentativa

Utilizamos o mÃ³dulo `time`:

```python
import time
```

### ğŸ“Œ Comportamento:

- Ao receber timeout:
  - Espera alguns segundos
  - Tenta resolver novamente

```python
except dns.resolver.LifetimeTimeout:
    print("caiu no timeout")
    time.sleep(3)
```

---

# ğŸ”„ Loop de ResoluÃ§Ã£o ContÃ­nua

## ğŸ” `while True`

- Garante que o script **continue tentando**
- SÃ³ para quando:
  - Encontrar um CNAME
  - NÃ£o houver CNAME
  - O domÃ­nio nÃ£o existir

---

## ğŸ“Œ Estrutura LÃ³gica

```python
while True:
    try:
        ...
        break
    except dns.resolver.NoAnswer:
        break
    except dns.resolver.NXDOMAIN:
        break
    except dns.resolver.LifetimeTimeout:
        print("caiu no timeout")
        time.sleep(3)
```

---

## âœ… Resultado Final

- Identifica **subdomÃ­nios que sÃ£o aliases**
- Detecta potenciais **subdomain takeovers**
- Trata:
  - DomÃ­nios inexistentes
  - AusÃªncia de CNAME
  - Timeouts DNS

- Ideal para **Reconhecimento em Pentest**
