## üö™ Scanner de Portas em Python

---

### üß† Conceito de Scanner de Portas

Um **scanner de portas** verifica se uma porta est√° aberta ou fechada em um host.

**Como funciona:**

- Tenta se conectar √† porta.
- Resultado:
  - üü¢ Conectou ‚Üí **porta aberta**
  - üî¥ Falhou ‚Üí **porta fechada**

---

### üîå Criando um cliente TCP em Python

Para testar a conex√£o com uma porta, usamos o m√≥dulo **socket**.

```python
import socket
cliente = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
```

#### üìñ Explica√ß√£o

| Par√¢metro     | Significado   |
| ------------- | ------------- |
| `AF_INET`     | Usa IPv4      |
| `SOCK_STREAM` | Protocolo TCP |

---

### ‚è±Ô∏è Ajustando o Timeout

Por padr√£o, o cliente espera muito tempo antes de considerar a conex√£o como falha, deixando o script lento.

```python
cliente.settimeout(0.1)
```

- O cliente espera **0,1 segundo**.
- Ap√≥s isso, considera **timeout**.

**Resultado:**

- ‚ö° Script mais r√°pido.

---

### üîó Estabelecendo conex√£o

Existem duas fun√ß√µes principais:

#### `connect()`

- Exige tratamento de erro com:

```python
try:
    cliente.connect((IP, porta))
except:
    pass
```

#### `connect_ex()` (mais simples)

- Retorna **c√≥digo de status**.
- N√£o precisa de `try/except`.

```python
codigo = cliente.connect_ex((IP, porta))
```

| C√≥digo retornado | Significado                            |
| ---------------- | -------------------------------------- |
| `0`              | Conex√£o estabelecida ‚Üí üü¢ Porta aberta |
| Outro valor      | Falha na conex√£o ‚Üí üî¥ Porta fechada    |

Exemplo:

```python
if codigo == 0:
    print("Porta aberta")
```

---

### üî¢ Quantas portas existem?

O total de portas TCP/UDP √©:

**0 a 65535 ‚Üí 65.536 portas**

---

### üîÅ Loop de varredura

O scanner ir√°:

1. Repetir um loop **65.536 vezes**.
2. A cada volta:
   - Criar um cliente TCP.
   - Testar uma porta.
   - Fechar o cliente.

Para organizar o c√≥digo, usamos uma fun√ß√£o:

```python
def checkport(IP, porta):
```

Essa fun√ß√£o:

- Recebe o endere√ßo IP.
- Recebe a porta.
- Testa a conex√£o.

---

### üåê Implementando resolu√ß√£o de dom√≠nios

O script fica lento se o dom√≠nio for resolvido a cada tentativa de conex√£o.

**Solu√ß√£o:**

- Resolver o dom√≠nio **uma √∫nica vez**.
- Usar o IP no restante do c√≥digo.

Fun√ß√£o de resolu√ß√£o:

```python
def dns(dominio):
    IP = socket.getaddrinfo(dominio, None, socket.AF_INET)
    return str(IP[0][4][0])
```

#### üìñ Explica√ß√£o

- `getaddrinfo()` retorna uma lista de tuplas.
- Precisamos apenas do endere√ßo IP:

```
IP[0][4][0]
```

**Vantagem:**

- ‚ö° Script mais r√°pido.
- Evita resolu√ß√£o de dom√≠nio a cada porta.

---

### ‚ö†Ô∏è Observa√ß√£o importante

- O projeto ainda est√° **em desenvolvimento**.
- No futuro, pode ser melhorado com:
  - üéØ Filtro de portas mais usadas.
  - ‚ö° Execu√ß√£o paralela.
  - üìä Relat√≥rios mais completos.

## üîé Descobrindo as portas mais utilizadas

O **Nmap** possui um arquivo com a lista das portas e a frequ√™ncia com que aparecem abertas:

```
/usr/share/nmap/nmap-services
```

Esse arquivo cont√©m:

- Nome do servi√ßo
- Porta
- Protocolo
- Frequ√™ncia de uso

Objetivo:

- Ordenar as portas por frequ√™ncia.
- Selecionar as **1000 portas TCP mais utilizadas**.

---

## üßπ Filtrando a lista com grep

Primeiro, removemos coment√°rios e pegamos apenas portas TCP.

### Removendo linhas comentadas

```bash
cat nmap-services | grep -v "^#"
```

| Comando        | Fun√ß√£o                                             |
| -------------- | -------------------------------------------------- |
| `grep -v "^#"` | Remove linhas que come√ßam com `#`                  |
| `-v`           | Busca reversa (mostra o que n√£o bate com o padr√£o) |

‚ö†Ô∏è Diferen√ßa importante:

- `grep -v "^#"` ‚Üí remove apenas linhas que come√ßam com `#`.
- `grep -v "#"` ‚Üí remove qualquer linha com `#` (perder√≠amos dados).

---

### Filtrando apenas portas TCP

```bash
grep "tcp"
```

Isso √© necess√°rio porque:

- O script trabalha apenas com **TCP**.

---

## üìä Ordenando a lista por frequ√™ncia

O comando `sort` organiza as linhas.

### Ordenar pela 3¬™ coluna (frequ√™ncia)

```bash
sort -k 3
```

Por padr√£o:

- Ordena em ordem crescente.
- As portas mais usadas ficam no final.

### Ordenar em ordem decrescente

```bash
sort -k 3 -r
```

| Flag   | Fun√ß√£o                      |
| ------ | --------------------------- |
| `-k 3` | Ordena pela 3¬™ coluna       |
| `-r`   | Ordem reversa (decrescente) |

---

## ‚úÇÔ∏è Selecionando as 1000 primeiras portas

```bash
head -n 1000
```

Para contar as linhas:

```bash
wc -l
```

---

### üßæ Comando completo

```bash
cat nmap-services | grep -v "^#" | grep "tcp" | sort -k 3 -r | head -n 1000 | wc -l
```

---

## üíæ Salvando em arquivo

```bash
cat nmap-services | grep -v "^#" | grep "tcp" | sort -k 3 -r | head -n 1000 > portas.txt
```

- Cria o arquivo `portas.txt` com as 1000 portas TCP mais usadas.

---

## üêç Script Python para filtrar porta e servi√ßo

O arquivo ainda possui informa√ß√µes desnecess√°rias.
Vamos extrair apenas:

- Porta
- Servi√ßo

Formato final:

```
porta:servi√ßo
```

Exemplo:

```
80:http
22:ssh
443:https
```

---

### L√≥gica do script

1. Abrir o arquivo bruto (`portas.txt`).
2. Filtrar porta e servi√ßo.
3. Salvar no arquivo final (`portasfiltradas.txt`).

---

### Estrutura b√°sica

```python
with open("portasfiltradas.txt", "w") as arquivo:
    with open("portas.txt") as file:
        for i in file.readlines():
```

---

### Separa√ß√£o dos dados

As colunas s√£o separadas por **TAB**.

```python
service = linha.split("\t")[0]
porta = linha.split("\t")[1].split("/")[0]
```

---

### Salvando no arquivo final

```python
arquivo.write(f"{porta}:{service}\n")
```

Resultado:

- Uma porta por linha.
- Apenas informa√ß√µes essenciais.

---

## üß† Utilizando o arquivo filtrado no scanner

Antes:

- O script testava **todas as 65.535 portas**.

Agora:

- Testar√° apenas as **1000 mais utilizadas**.
- Muito mais r√°pido e eficiente.

---

## üì¶ Fun√ß√£o para criar dicion√°rio de portas

O usu√°rio informar√°:

- Dom√≠nio
- Arquivo de portas

A fun√ß√£o:

- Abre o arquivo de portas.
- Cria um dicion√°rio com:
  - chave ‚Üí porta
  - valor ‚Üí servi√ßo

---

### Fun√ß√£o criarDicionario

```python
def criarDicionario(arquivo_portas):
    portas_dicionario = {}

    with open(arquivo_portas) as file:
        for i in file.readlines():
            linha = i.replace("\n", "").split(":")

            porta = int(linha[0])
            service = linha[1]
            portas_dicionario[porta] = service

    return portas_dicionario
```

---

## üîÅ Uso no script principal

Depois de criar o dicion√°rio:

- Percorremos cada porta.
- Chamamos a fun√ß√£o `checkport()` para testar a conex√£o.

Isso torna o scanner:

- ‚ö° Mais r√°pido
- üéØ Mais eficiente
- üìâ Com menos tr√°fego desnecess√°rio
