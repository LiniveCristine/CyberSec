## ğŸšª Scanner de Portas em Python

---

### ğŸ§  Conceito de Scanner de Portas

Um **scanner de portas** verifica se uma porta estÃ¡ aberta ou fechada em um host.

**Como funciona:**

- Tenta se conectar Ã  porta.
- Resultado:
  - ğŸŸ¢ Conectou â†’ **porta aberta**
  - ğŸ”´ Falhou â†’ **porta fechada**

---

### ğŸ”Œ Criando um cliente TCP em Python

Para testar a conexÃ£o com uma porta, usamos o mÃ³dulo **socket**.

```python
import socket
cliente = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
```

#### ğŸ“– ExplicaÃ§Ã£o

| ParÃ¢metro     | Significado   |
| ------------- | ------------- |
| `AF_INET`     | Usa IPv4      |
| `SOCK_STREAM` | Protocolo TCP |

---

### â±ï¸ Ajustando o Timeout

Por padrÃ£o, o cliente espera muito tempo antes de considerar a conexÃ£o como falha, deixando o script lento.

```python
cliente.settimeout(0.1)
```

- O cliente espera **0,1 segundo**.
- ApÃ³s isso, considera **timeout**.

**Resultado:**

- âš¡ Script mais rÃ¡pido.

---

### ğŸ”— Estabelecendo conexÃ£o

Existem duas funÃ§Ãµes principais:

#### `connect()`

- Exige tratamento de erro com:

```python
try:
    cliente.connect((IP, porta))
except:
    pass
```

#### `connect_ex()` (mais simples)

- Retorna **cÃ³digo de status**.
- NÃ£o precisa de `try/except`.

```python
codigo = cliente.connect_ex((IP, porta))
```

| CÃ³digo retornado | Significado                            |
| ---------------- | -------------------------------------- |
| `0`              | ConexÃ£o estabelecida â†’ ğŸŸ¢ Porta aberta |
| Outro valor      | Falha na conexÃ£o â†’ ğŸ”´ Porta fechada    |

Exemplo:

```python
if codigo == 0:
    print("Porta aberta")
```

---

### ğŸ”¢ Quantas portas existem?

O total de portas TCP/UDP Ã©:

**0 a 65535 â†’ 65.536 portas**

---

### ğŸ” Loop de varredura

O scanner irÃ¡:

1. Repetir um loop **65.536 vezes**.
2. A cada volta:
   - Criar um cliente TCP.
   - Testar uma porta.
   - Fechar o cliente.

Para organizar o cÃ³digo, usamos uma funÃ§Ã£o:

```python
def checkport(IP, porta):
```

Essa funÃ§Ã£o:

- Recebe o endereÃ§o IP.
- Recebe a porta.
- Testa a conexÃ£o.

---

### ğŸŒ Implementando resoluÃ§Ã£o de domÃ­nios

O script fica lento se o domÃ­nio for resolvido a cada tentativa de conexÃ£o.

**SoluÃ§Ã£o:**

- Resolver o domÃ­nio **uma Ãºnica vez**.
- Usar o IP no restante do cÃ³digo.

FunÃ§Ã£o de resoluÃ§Ã£o:

```python
def dns(dominio):
    IP = socket.getaddrinfo(dominio, None, socket.AF_INET)
    return str(IP[0][4][0])
```

#### ğŸ“– ExplicaÃ§Ã£o

- `getaddrinfo()` retorna uma lista de tuplas.
- Precisamos apenas do endereÃ§o IP:

```
IP[0][4][0]
```

**Vantagem:**

- âš¡ Script mais rÃ¡pido.
- Evita resoluÃ§Ã£o de domÃ­nio a cada porta.

---

### âš ï¸ ObservaÃ§Ã£o importante

- O projeto ainda estÃ¡ **em desenvolvimento**.
- No futuro, pode ser melhorado com:
  - ğŸ¯ Filtro de portas mais usadas.
  - âš¡ ExecuÃ§Ã£o paralela.
  - ğŸ“Š RelatÃ³rios mais completos.

## ğŸ” Descobrindo as portas mais utilizadas

O **Nmap** possui um arquivo com a lista das portas e a frequÃªncia com que aparecem abertas:

```
/usr/share/nmap/nmap-services
```

Esse arquivo contÃ©m:

- Nome do serviÃ§o
- Porta
- Protocolo
- FrequÃªncia de uso

Objetivo:

- Ordenar as portas por frequÃªncia.
- Selecionar as **1000 portas TCP mais utilizadas**.

---

## ğŸ§¹ Filtrando a lista com grep

Primeiro, removemos comentÃ¡rios e pegamos apenas portas TCP.

### Removendo linhas comentadas

```bash
cat nmap-services | grep -v "^#"
```

| Comando        | FunÃ§Ã£o                                             |
| -------------- | -------------------------------------------------- |
| `grep -v "^#"` | Remove linhas que comeÃ§am com `#`                  |
| `-v`           | Busca reversa (mostra o que nÃ£o bate com o padrÃ£o) |

âš ï¸ DiferenÃ§a importante:

- `grep -v "^#"` â†’ remove apenas linhas que comeÃ§am com `#`.
- `grep -v "#"` â†’ remove qualquer linha com `#` (perderÃ­amos dados).

---

### Filtrando apenas portas TCP

```bash
grep "tcp"
```

Isso Ã© necessÃ¡rio porque:

- O script trabalha apenas com **TCP**.

---

## ğŸ“Š Ordenando a lista por frequÃªncia

O comando `sort` organiza as linhas.

### Ordenar pela 3Âª coluna (frequÃªncia)

```bash
sort -k 3
```

Por padrÃ£o:

- Ordena em ordem crescente.
- As portas mais usadas ficam no final.

### Ordenar em ordem decrescente

```bash
sort -k 3 -r
```

| Flag   | FunÃ§Ã£o                      |
| ------ | --------------------------- |
| `-k 3` | Ordena pela 3Âª coluna       |
| `-r`   | Ordem reversa (decrescente) |

---

## âœ‚ï¸ Selecionando as 1000 primeiras portas

```bash
head -n 1000
```

Para contar as linhas:

```bash
wc -l
```

---

### ğŸ§¾ Comando completo

```bash
cat nmap-services | grep -v "^#" | grep "tcp" | sort -k 3 -r | head -n 1000 | wc -l
```

---

## ğŸ’¾ Salvando em arquivo

```bash
cat nmap-services | grep -v "^#" | grep "tcp" | sort -k 3 -r | head -n 1000 > portas.txt
```

- Cria o arquivo `portas.txt` com as 1000 portas TCP mais usadas.

---

## ğŸ Script Python para filtrar porta e serviÃ§o

O arquivo ainda possui informaÃ§Ãµes desnecessÃ¡rias.
Vamos extrair apenas:

- Porta
- ServiÃ§o

Formato final:

```
porta:serviÃ§o
```

Exemplo:

```
80:http
22:ssh
443:https
```

---

### LÃ³gica do script

1. Abrir o arquivo bruto (`portas.txt`).
2. Filtrar porta e serviÃ§o.
3. Salvar no arquivo final (`portasfiltradas.txt`).

---

### Estrutura bÃ¡sica

```python
with open("portasfiltradas.txt", "w") as arquivo:
    with open("portas.txt") as file:
        for i in file.readlines():
```

---

### SeparaÃ§Ã£o dos dados

As colunas sÃ£o separadas por **TAB**.

```python
service = linha.split("\t")[0]
porta = linha.split("\t")[1].split("/")[0]
```

---

### Salvando no arquivo final

```python
arquivo.write(f"{porta}:{service}\n")
```

Resultado:

- Uma porta por linha.
- Apenas informaÃ§Ãµes essenciais.

---

## ğŸ§  Utilizando o arquivo filtrado no scanner

Antes:

- O script testava **todas as 65.535 portas**.

Agora:

- TestarÃ¡ apenas as **1000 mais utilizadas**.
- Muito mais rÃ¡pido e eficiente.

---

## ğŸ“¦ FunÃ§Ã£o para criar dicionÃ¡rio de portas

O usuÃ¡rio informarÃ¡:

- DomÃ­nio
- Arquivo de portas

A funÃ§Ã£o:

- Abre o arquivo de portas.
- Cria um dicionÃ¡rio com:
  - chave â†’ porta
  - valor â†’ serviÃ§o

---

### FunÃ§Ã£o criarDicionario

```python
def criarDicionario(arquivo_portas):
    portas_dicionario = {}

    with open(arquivo_portas) as file:
        for i in file.readlines():
            linha = i.replace("\n", "").split(":")

            porta = int(linha[0])
            service = linha[1]
            portas_dicionario[porta] = service

    return portas_dicionario
```

---

## ğŸ” Uso no script principal

Depois de criar o dicionÃ¡rio:

- Percorremos cada porta.
- Chamamos a funÃ§Ã£o `checkport()` para testar a conexÃ£o.

Isso torna o scanner:

- âš¡ Mais rÃ¡pido
- ğŸ¯ Mais eficiente
- ğŸ“‰ Com menos trÃ¡fego desnecessÃ¡rio

---

## ğŸ§µ Threading em Python

O mÃ³dulo **threading** permite executar **vÃ¡rias partes do programa ao mesmo tempo**, aumentando a **performance** do script.

Ele Ã© ideal para tarefas como:

- ğŸŒ RequisiÃ§Ãµes web
- ğŸ“‚ Leitura de arquivos
- ğŸ” Scanners de portas
- âš¡ OperaÃ§Ãµes repetitivas e independentes

---

## ğŸš€ Por que usar threads

Sem threads:

- O script executa uma tarefa por vez.
- Pode ficar lento, especialmente em operaÃ§Ãµes de rede.

Com threads:

- VÃ¡rias tarefas sÃ£o executadas simultaneamente.
- O tempo total de execuÃ§Ã£o diminui.

ğŸ“Œ Exemplo:

- Sem threads: testa portas uma por uma.
- Com threads: testa vÃ¡rias portas ao mesmo tempo.

---

## ğŸ§° Importando o mÃ³dulo

```python
import threading
```

---

## ğŸ§µ Criando uma thread

Para iniciar uma thread, usamos:

```python
t = threading.Thread(target=checkport, args=(IP, porta, portas_dicionario[porta]))
```

### ParÃ¢metros principais

| ParÃ¢metro | FunÃ§Ã£o                                              |
| --------- | --------------------------------------------------- |
| `target`  | FunÃ§Ã£o que serÃ¡ executada na thread                 |
| `args`    | Argumentos que a funÃ§Ã£o precisa (em forma de tupla) |

---

## â–¶ï¸ Iniciando a thread

Depois de criar a thread:

```python
t.start()
```

Isso faz com que a funÃ§Ã£o definida em `target`:

- Seja executada simultaneamente ao restante do programa.

---

## ğŸ” Exemplo prÃ¡tico com scanner de portas

```python
for porta in portas_dicionario:
    t = threading.Thread(
        target=checkport,
        args=(IP, porta, portas_dicionario[porta])
    )
    t.start()
```

Nesse caso:

- Cada porta serÃ¡ testada em uma thread diferente.
- O scanner se torna muito mais rÃ¡pido.

---

## âš ï¸ ObservaÃ§Ã£o importante

- Muitas threads ao mesmo tempo podem:
  - Sobrecarregar o sistema
  - Gerar erros de conexÃ£o

Por isso, em projetos maiores:

- Usamos **limite de threads** ou **fila de tarefas**.

---

## ğŸ§  Resumo rÃ¡pido

- `threading` permite execuÃ§Ã£o simultÃ¢nea.
- Aumenta a velocidade de scripts de rede.
- Cada thread executa uma funÃ§Ã£o independente.
- Ideal para scanners e automaÃ§Ãµes.

---
