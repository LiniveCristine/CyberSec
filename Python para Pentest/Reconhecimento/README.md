# ğŸ” Reconhecimento (Recon)

## ğŸŒ ResoluÃ§Ã£o de DomÃ­nio com Brute Force

O objetivo Ã© identificar **subdomÃ­nios vÃ¡lidos** de um domÃ­nio principal por meio de **forÃ§a bruta**, resolvendo nomes DNS programaticamente com Python.

---

## ğŸ MÃ³dulo Socket

- Utilizamos o mÃ³dulo **socket**
- Permite trabalhar com **resoluÃ§Ã£o de domÃ­nios (DNS)**

```python
import socket
```

---

## ğŸ§© FunÃ§Ã£o `getaddrinfo()`

A funÃ§Ã£o `socket.getaddrinfo()` retorna uma **lista de informaÃ§Ãµes** sobre um domÃ­nio, incluindo endereÃ§os IP.

### ğŸ“Œ Argumentos utilizados:

- **DomÃ­nio:** ex: `google.com`
- **Porta:** `None`
- **Tipo de IP:**
  - IPv4 â†’ `socket.AF_INET`
  - IPv6 â†’ `socket.AF_INET6`

### ğŸ“Œ Exemplo (IPv4):

```python
dados = socket.getaddrinfo("google.com", None, socket.AF_INET)
```

---

## ğŸ“¥ Extraindo o IP da Lista

- O IP estÃ¡ dentro da estrutura retornada pela funÃ§Ã£o

```python
IP = dados[1][4][0]
```

---

# ğŸ” Brute Force de SubdomÃ­nios

A resoluÃ§Ã£o bÃ¡sica estÃ¡ feita, mas agora queremos resolver **vÃ¡rios subdomÃ­nios automaticamente**.

---

## ğŸ“„ Wordlist de SubdomÃ­nios

- Usamos uma **lista de subdomÃ­nios comuns**
- Exemplo (SecLists):

```bash
wget https://github.com/danielmiessler/SecLists/raw/refs/heads/master/Discovery/DNS/subdomains-top1million-110000.txt
```

---

## ğŸ“‚ Leitura da Wordlist (`with open`)

- Forma mais eficiente de ler arquivos
- NÃ£o Ã© necessÃ¡rio fechar o arquivo manualmente

```python
with open("meuarquivo.txt") as wordlist:
```

- `wordlist` serÃ¡ a variÃ¡vel que contÃ©m os subdomÃ­nios
- Em seguida, utilizamos um **loop for** para testar cada subdomÃ­nio

---

# ğŸ§  FunÃ§Ãµes de ResoluÃ§Ã£o IPv4 e IPv6

Criamos funÃ§Ãµes separadas para resolver:

- **IPv4**
- **IPv6**

### ğŸ“Œ Tratamento de Erros

- Utilizamos `try...except`
- Quando um domÃ­nio nÃ£o pode ser resolvido, ocorre o erro:
  - `socket.gaierror`

ğŸ“Œ Comportamento das funÃ§Ãµes:

- Se ocorrer erro â†’ retorna `0`
- Se resolver corretamente â†’ retorna o **IP**

Esse retorno Ã© essencial para registrar os resultados depois.

---

# ğŸš€ Evitando ResoluÃ§Ãµes Repetidas

Para melhorar a **performance do script**, evitamos resolver o mesmo domÃ­nio mais de uma vez.

```python
resolvidos = []
```

### ğŸ“Œ LÃ³gica:

- Antes de resolver, verificamos se o domÃ­nio jÃ¡ foi analisado

```python
if dominio_montado not in resolvidos:
```

- Se nÃ£o estiver:
  - Resolve IPv4 e IPv6
  - Adiciona o domÃ­nio Ã  lista `resolvidos`

---

# ğŸ—‚ï¸ Registro das ResoluÃ§Ãµes

Vamos armazenar os resultados em **JSON**, separados por tipo de IP.

---

## ğŸ“¦ DicionÃ¡rios de Armazenamento

```python
dominios4 = {}
dominios6 = {}
```

### ğŸ“Œ Armazenamento Condicional

- Apenas registramos se o retorno **nÃ£o for 0**

```python
if IPv4 != 0:
    dominios4[dominio_montado] = IPv4

if IPv6 != 0:
    dominios6[dominio_montado] = IPv6
```

---

## ğŸ”— Unindo os Registros

- Criamos um dicionÃ¡rio final com todos os resultados

```python
registros_completos = {}
registros_completos["IPv4"] = dominios4
registros_completos["IPv6"] = dominios6
```

---

# ğŸ“„ Gerando o JSON

- Utilizamos o mÃ³dulo `json`

```python
import json
registros_JSON = json.dumps(registros_completos)
```

---

# ğŸ’¾ Criando o Arquivo de SaÃ­da

- O arquivo terÃ¡ o nome do domÃ­nio informado pelo usuÃ¡rio

```python
with open(f"{dominio}-subdomains.json", "w") as f:
    f.write(registros_JSON)
```

ğŸ“Œ ObservaÃ§Ãµes:

- `"w"` â†’ modo de escrita
- `f` â†’ variÃ¡vel que representa o arquivo
- Cada domÃ­nio terÃ¡ seu **arquivo JSON exclusivo**

---

## âœ… Resultado Final

- Script realiza **brute force de subdomÃ­nios**
- Resolve **IPv4 e IPv6**
- Evita resoluÃ§Ãµes duplicadas
- Armazena resultados organizados em **JSON**
- Ideal para **fase de reconhecimento (Recon)**
